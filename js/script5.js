'use strict';
// //функции-конструкторы.

// //функция по классификации типов данных является объектом и в нее можно записать какие-то методы и свойства;

// // существует длинный синтаксис для создания типов двнных который начинается с ключевого слова new
// const num = new Number(3); 
// console.log(num);


// function User (name, id) { // функция-конструктор с помощью которой можно создать новый объект
//     this.name = name;
//     this.id = id;
//     this.human = true;
//     this.hello  = function () { //создание метода 
//         console.log(`Hello ${this.name}`);
//     };
// }

// //метод prototype используется когда мы не имеем доступа к прототипу или  не можем менять прототип
// User.prototype.exit = function () {
//     console.log(`пользователь ${this.name} ушел`);
// };
// // то. этот метод будет наследоваться прототипно у всех потомков этого объекта
// //мы указываем не протитип, как это было в setPrototype, когда одно наследуется от другого, а просто добавляем новые свойства или методы в уже существующий объект

// const ivan = new User('Ivan', 28); //внутри этой перенменной уже находится объект
// const alex = new User('Alex', 20);

// ivan.hello(); //используем метод объекта 
// alex.hello();

// ivan.exit(); // используем метод созданный с помощью прототипа

// console.log(ivan);
// console.log(alex);

// // в функции-конструкторе return не нужен тк ими мы ничего не возвращаем


// //конструкторы нужны для создания новых однотипных объектов, используется везде где есть шаблонизация

// //в стандарте ES6 появились классы (синтаксический сахар, те красивая обертка всего вышеописанного функционала)
// //в JS изначально классов не было они появились в качестве синтаксического сахара в ES6




//Контекст вызова функции this - это то что окружает функцию и в каких условиях она вызывается

//функция может вызываться 4 способами и в каждом контекст вызова отличается
//1. просто вызов функции

function showThis () {
    console.log(this);
}
showThis();
//если функция просто запускается таким образом, когда мы используем в ней контекст, то этот контекст будет ссылаться на глобальный объект window. 
//это правило верно только без использования use strict
//используя use strict контект будет undefined

function showThisYet (a, b) {
    console.log(this);
    function sum () { //используем замыкание функции
        console.log(this);
        return a + b;
    }
    console.log(sum());
}
showThisYet(4, 5);

//2. вызов функции как метода объекта

const obj = {
    a: 20,
    b: 15,
    sum: function sum () {
        console.log(this);
    }
}
obj.sum();
// если мы используем метод внутри объекта, то контекст вызова всегда будет ссылаться на этот объект

const objOne = {
    a: 20,
    b: 15,
    sum: function sum () {
        function shout () {
            console.log(this);
        }
        shout();
    }
}
objOne.sum();
// контекст вызова такой функции равен undefined, т.к. это простой выхов функии и он уже не относится к методу объекта, это функция которая запускается внутри метода;

//3. метод использования функции через оператор new

function User (name, id) { // функция-конструктор с помощью которой можно создать новый объект
    this.name = name;
    this.id = id;
    this.human = true;
    this.hello  = function () { 
                console.log('Hello ' + this.name);
            };
}
let ivan = new User('Ivan', 28);
// внутри функций-конструкторов контекстом вызова будет новый только что созданный объект

//4. ручное присвоение this любой функции

 function sayName (surname) {
     console.log(this);
     console.log(this.name + surname);
 }

 const user = {
     name: 'john'
 };

 sayName.call(user, 'Smith');
 sayName.apply(user, ['smith']);
 //с помошью этих методов мы говорим функции с каким объктом ей работайть и использовать его данные, т.о. эта функция приобрела контекст вызова;
 // разница: в call аргументы передаюся черезе заптую в виде строки, а в apply в виде массива через запятую,
 // а первым аргументом указывается имя объекта с которым необходимо работать

 function count (num) {
     return this * num;
 }

 const double = count.bind(2);
 console.log(double(3));
 console.log(double(13));
 //этот метод создает новую функцию связанную с определнным контекстом и под нее подвязывает контекст

 //1. обычная функция: this = window, use strict = undefined;
 //2. контекст у методов объектов = сам объект;
 //3. this в конструкторах и классах = новый экземпляр объекта;
 //4. ручная привязка this: call, apply, bind;


 const btn = document.querySelector('button');

btn.addEventListener('click', function () {
    console.log(this);
    this.style.backgroundColor = 'red';
});
// в таком случае контекстом вызова будет сам элемент на котором произошло событие, те когда обработчик события написан в классическм стиле (не стралочной функцией )
//почти всегда this = e.target



//у стрелочной функции нет своего контекста вызова, она всегда его будет брать у своего родителя
const objTwo = {
    num: 5,
    sayNumber: function () {
        const say = () => {
            console.log(this);
            console.log(this.num);
        };
        say();
    }
};
objTwo.sayNumber();
// в данном случае контекстом вызова будет объект

// const calc = (a) => {  // стрелочная функция
//     return a * 2;
// };

//  если тело стрелочной функции помещается на одну строку, то запись можно сделать без фигурных скобок
// const calc = (a) => a * 2;

// если стрелочная функция принимает только один аргумент, то можно не использовать круглые скобки
const calc = a => a * 2;
console.log(calc(4));

//контекст вызова в обработчике события с использованием стрелочной функции теряется и this использовать нельзя // = undefined 
btn.addEventListener('click', () => {
    this.style.backgroundColor = 'red';
});

// вместо этого используем e.target
btn.addEventListener('click', (e) => {
    e.target.style.backgroundColor = 'red';
});