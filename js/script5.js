'use strict';
// //функции-конструкторы.

// //функция по классификации типов данных является объектом и в нее можно записать какие-то методы и свойства;

// // существует длинный синтаксис для создания типов двнных который начинается с ключевого слова new
// const num = new Number(3); 
// console.log(num);


// function User (name, id) { // функция-конструктор с помощью которой можно создать новый объект
//     this.name = name;
//     this.id = id;
//     this.human = true;
//     this.hello  = function () { //создание метода 
//         console.log(`Hello ${this.name}`);
//     };
// }

// //метод prototype используется когда мы не имеем доступа к прототипу или  не можем менять прототип
// User.prototype.exit = function () {
//     console.log(`пользователь ${this.name} ушел`);
// };
// // то. этот метод будет наследоваться прототипно у всех потомков этого объекта
// //мы указываем не протитип, как это было в setPrototype, когда одно наследуется от другого, а просто добавляем новые свойства или методы в уже существующий объект

// const ivan = new User('Ivan', 28); //внутри этой перенменной уже находится объект
// const alex = new User('Alex', 20);

// ivan.hello(); //используем метод объекта 
// alex.hello();

// ivan.exit(); // используем метод созданный с помощью прототипа

// console.log(ivan);
// console.log(alex);

// // в функции-конструкторе return не нужен тк ими мы ничего не возвращаем


// //конструкторы нужны для создания новых однотипных объектов, используется везде где есть шаблонизация

// //в стандарте ES6 появились классы (синтаксический сахар, те красивая обертка всего вышеописанного функционала)
// //в JS изначально классов не было они появились в качестве синтаксического сахара в ES6




//Контекст вызова функции this - это то что окружает функцию и в каких условиях она вызывается

//функция может вызываться 4 способами и в каждом контекст вызова отличается
//1. просто вызов функции

function showThis () {
    console.log(this);
}
showThis();
//если функция просто запускается таким образом, когда мы используем в ней контекст, то этот контекст будет ссылаться на глобальный объект window. 
//это правило верно только без использования use strict
//используя use strict контект будет undefined

function showThisYet (a, b) {
    console.log(this);
    function sum () { //используем замыкание функции
        console.log(this);
        return a + b;
    }
    console.log(sum());
}
showThisYet(4, 5);

//2. вызов функции как метода объекта

const obj = {
    a: 20,
    b: 15,
    sum: function sum () {
        console.log(this);
    }
}
obj.sum();
// если мы используем метод внутри объекта, то контекст вызова всегда будет ссылаться на этот объект

const objOne = {
    a: 20,
    b: 15,
    sum: function sum () {
        function shout () {
            console.log(this);
        }
        shout();
    }
}
objOne.sum();
// контекст вызова такой функции равен undefined, т.к. это простой выхов функии и он уже не относится к методу объекта, это функция которая запускается внутри метода;

//3. метод использования функции через оператор new

function User (name, id) { // функция-конструктор с помощью которой можно создать новый объект
    this.name = name;
    this.id = id;
    this.human = true;
    this.hello  = function () { 
                console.log('Hello ' + this.name);
            };
}
let ivan = new User('Ivan', 28);
// внутри функций-конструкторов контекстом вызова будет новый только что созданный объект

//4. ручное присвоение this любой функции

 function sayName (surname) {
     console.log(this);
     console.log(this.name + surname);
 }

 const user = {
     name: 'john'
 };

 sayName.call(user, 'Smith');
 sayName.apply(user, ['smith']);
 //с помошью этих методов мы говорим функции с каким объктом ей работайть и использовать его данные, т.о. эта функция приобрела контекст вызова;
 // разница: в call аргументы передаюся черезе заптую в виде строки, а в apply в виде массива через запятую,
 // а первым аргументом указывается имя объекта с которым необходимо работать

 function count (num) {
     return this * num;
 }

 const double = count.bind(2);
 console.log(double(3));
 console.log(double(13));
 //этот метод создает новую функцию связанную с определнным контекстом и под нее подвязывает контекст

 //1. обычная функция: this = window, use strict = undefined;
 //2. контекст у методов объектов = сам объект;
 //3. this в конструкторах и классах = новый экземпляр объекта;
 //4. ручная привязка this: call, apply, bind;


 const btn = document.querySelector('button');

btn.addEventListener('click', function () {
    console.log(this);
    this.style.backgroundColor = 'red';
});
// в таком случае контекстом вызова будет сам элемент на котором произошло событие, те когда обработчик события написан в классическм стиле (не стралочной функцией )
//почти всегда this = e.target



//у стрелочной функции нет своего контекста вызова, она всегда его будет брать у своего родителя
const objTwo = {
    num: 5,
    sayNumber: function () {
        const say = () => {
            console.log(this);
            console.log(this.num);
        };
        say();
    }
};
objTwo.sayNumber();
// в данном случае контекстом вызова будет объект

// const calc = (a) => {  // стрелочная функция
//     return a * 2;
// };

//  если тело стрелочной функции помещается на одну строку, то запись можно сделать без фигурных скобок
// const calc = (a) => a * 2;

// если стрелочная функция принимает только один аргумент, то можно не использовать круглые скобки
const calc = a => a * 2;
console.log(calc(4));

//контекст вызова в обработчике события с использованием стрелочной функции теряется и this использовать нельзя // = undefined 
btn.addEventListener('click', () => {
    this.style.backgroundColor = 'red';
});

// вместо этого используем e.target
btn.addEventListener('click', (e) => {
    e.target.style.backgroundColor = 'red';
});



// КЛАССЫ - красивая обертка функций конструкторов, служат для создания новых объектов


//название класса задается с большой буквы
class Rectangle {
    constructor(width, height) { // свойство constructor занимается конструированием классов, в параметрах указывается то, что будет приходть извне при создании экземпляра класса
        this.width = width; //в каждый новый объект записываем новое свойтво
        this.height = height;
    }     // точка с запятой не ставится

    calcArea() { //создаем метод
        return this.height * this.width;
    }
}



const square = new Rectangle(10, 10); // создаем объект образованный при помощи класса
const long = new Rectangle(20, 100);

console.log(square.calcArea()); // у объекта используем метод и выведем в консоль
console.log(long.calcArea());

class ColoredRectangleWithText extends Rectangle { // используем наследование свойств у другого класса с помощью ключевого слова
    constructor(width, height, text, bgColor) {
        super(height, width); //этот метод вызывает супер конструктор родителя (те не нужно повторять свойства из родителя, они автоматически перейдут в новый класс за счет наследования)
        // Важно!!! метод super() всегда дожен быть на первом месте в конструкторе // в качестве аргументов нужно указывать те свойства которые хотим использовать
        this.text = text;
        this.bgColor = bgColor;
    }

    showMyProps() {
        console.log(`текст: ${this.text}, цвет: ${this.bgColor}`);
    }
}

const div = new ColoredRectangleWithText(20, 25, 'hello', 'red');

div.showMyProps();
console.log(div.calcArea());


//принципы объектно-ориентированного программирования
//1. абстракция - те когда мы отделяем концепцию от ее экземпляра
//2. наследование - способность нашего объекта или класса базироваться на другом объекте или классе (главный механизм для повторного использования кода)
// и при этом наследственное отношение классов четко будет определять их иерархию

